Text-align guidance:
Don't justify text, long blocks of text should be left-aligned and do not center large blocks of text.

LINE-HEIGHT:
Sets the height of text and is commonly used to set distance between multiple lines of text.
line-height: 1.5;{unitless is just a number that multiplies the font size. Commonly used.} percentage; pixels; ems;
line-height guidance:
Headings should be <1.5 and regular text 1.5-2 to improve readability.

LETTER-SPACING:
Sets the horizontal space between characters.
letter-spacing: 8px;{pixels commonly used} percentage; ems;
No unitless value
letter-spacing guidance:
We often apply small negative px value to headings to improve readability.

FONT-SIZE:
Sets the size of the text.
font-size: 16px;(commonly used) pt; in; cm; mm;
Absolute units:
Size is fixed and does not change in relation to parent elements
Avoid using absolute units because they are static. Web pages are all about dynamic and adaptable design that can fit different screen sizes and resolutions.
Relative units:
Size is based on the size of a parent element and adjusts proportionally to changes in the parent element.
Examples include % em rem vh vw
Pixels:
A single point of light on a digital display
A CSS pixel has a length of 1/96 inch (0.0104 inch) hence 10px is 0.104 inch
font-size guidance:
Regular text should be 16px - 32px and headings can be >60px
Use a type-scale which provides a structured hierarchy of font sizes to create visual consistency and limits choices.
h1 -> >60px
h2 -> 48px
h3 -> 40px
h4 -> 32px
h5 -> 24px
p -> 20px
a -> 16px
smaller -> 12px
From bottom to top, one level to another is multiplication by 1.25

TYPEFACE - A specific font
Characters with consistent visual characteristics
Typefaces are organised into groups:
SERIF -> Extra details on the end of strokes e.g. TIMES. A classic feel used by brands to communicate luxury and reliability. Used for high-end products.
SANS-SERIF -> Straight ends and much cleaner e.g. ARIAL. A modern and clean feel used by brands to communicate simplicity and clarity. Used majorly by tech companies.
MONOSPACE -> Letters are the same width e.g. COURIER NEW. A technical feel used by rands to communicate accuracy and precision. Used for very technical products.
CURSIVE -> Joining strokes or mimic handwriting e.g. COMIC SANS MS. A personal feel used to communicate with people on a more emotional level. Used for weddings and blogs.
DISPLAY -> Attention grabbing and artistic e.g. IMPACT. A creative feel used by brands to communicate playfulness and rule-breaking. Mainly used by fun brands.
FONT-FAMILY:
Sets a prioritised list of font names(typeface) or font categories.
font-family: 'Tahoma', sans-serif; Tahoma -> first choice, sans-serif -> fall back
Fonts will only display in your browser if they are installed on your machine e.g Tahoma -> windows(99.9%), mac(91.9%)
font guidance:
To play safe pick a popular sans-serif font examples below. sans-serif is also a very popular choice for tech
Roboto
Open Sans
Montserrat
Poppins
Inter
Select one or two fonts, but no more.
try poppins for headings and rubik for regular text
Google fonts:
Fonts are available online and do not rely on the fonts installed on an individual user's device
Very easy to add to your projects
1. Find font you like
2. Embed font with a link tag in html
3. Add font family in css
url -> fonts.google.com

Text Color:
Named Colors:
CSS includes 147 named colors that browsers recognise. RED SALMON YELLOW KHAKI BLUE AQUAMARINE GREEN OLIVE
These should not be used as they are very limited and not suitable for professional projects
Color Systems:
A structured method for creating different colors using a set of primary colors and rules for mixing them.
Subtractive color system:
Commonly used in print and painting
Start with white and apply colored pigments that absorb light
Black when all mixed
Additive color system:
Commonly used in electronic displays
Start with black and emit light at different intensities
White when all mixed
Pixel:
A pixel is made of red, green and blue lights with adjustable intensities.
RGB values range from 0(zero){minimum intensity} to 255{maximum intensity} Red(0-255) Green(0-255) Blue(0-255)
RGB and Hexadecimal notation:
Color values can be represented in either RGB or Hexadecimal notation e.g. rgb(152, 116, 249) Hexadecimal -> #9874F9
The example above of notation is used across CSS for specifying colors for text, backgrounds, shadows and more.
Hexadecimal is most commonly used
Shades of grey:
When all the channels of RGB have the same value we get a shade of grey e.g. rgb(64, 64, 64) #404040  rgb(136, 136, 136) #888888   rgb(192, 192, 192) #C0C0C0
On the extremes to get white, rgb(255, 255, 255) #FFFFFF  and to get black, rgb(0, 0, 0) #000000
CSS Color:
Specifies the color of text
color: #9874F9; rgb; rgba; hsl;
hex is most commonly used
color guidance:
Have at least 2 colors in your color palette, a primary and grey color
For both primary and grey color there can be tints(lighter versions of the base color), base color and shades(darker versions of the base color). Grey can be a dark version of a color.
Primary colors are used to highlight important parts of a page and tints and shades can be used to create contrast.
The grey color with tints and shades often used for fonts
Color is used in images and illustrations for consistency
Color is used throughout design for components and sections
Adding a secondary color introduces variety and contrast often making designs more appealing
Primary colors are typically used on dominant elements such as buttons, background colors, section headings, icons and more.
Tertiary colors add further variety


CSS SELECTORS:
Selectors allow us to select HTML elements to apply CSS rules.
Range of CSS Selectors:
There is a large range of CSS selectors that allow us to apply styles from broad styling to specific visual details
# -> Basic Selectors(commonly used)
ul > li -> combinator selectors
a:hover -> pseudo-class selectors
::before -> pseudo-elements selectors
Type Selectors:
Selects elements based on their tag name e.g. h1 { font-size: 20px; color: blue;}
type selector guidance:
It is useful for setting global styles to ensure consistency
The cascade:
Means flows from one stage to the next.
This is how styles declared later will take priority. e.g. h1 { color: blue; } h1 { color:green; } green overrides blue.
Also, index.html -> <head> <link rel="stylesheet" href="app.css"> <link rel="stylesheet" href="app2.css"> </head>
app.css -> h1 { font-size: 12px; } app2.css -> h1 { font-size: 52px } 52px overrides 12px
Grouping Selectors:
Selectors can be comma separated to apply shared styles e.g. h1 { color: blue; } h2 { color: blue; }
h1, h2 { color: blue; }
Grouping Selectors and cascading:
We can use the css cascading to add new rules to previous rules
h1 { font-size: 62px; color: #495057; } h2 {font-size: 48px; color: #495057;} can be rewritten as below using cascading to our advantage:
h1, h2 { color: #495057; } h1 { font-size: 62px; } h2 { font-size: 48px; }
The ID Selector:
Selects an element based on a unique id attribute and can only be used once.
The class selector:
Selects one or more elements based on a class attribute that can be used multiple times.
selector guidance:
Classes are often preferred over ids because they offer greater flexibility and reusability.
It is common to use type selectors for global styles and class selectors for more specific visual styles.
Classes for components(piece of reusable ui e.g. buttons) are designed to be combined on a single html element for a modular approach to styling.
Pseudo-classes:
Defines styles for a specific state or condition of an html element.
A keyword with a colon added to the end of a selector. e.g. a:hover, hover is a pseudo-class name
State pseudo-classes:
Dynamic styling based on user interaction and commonly used for hyperlinks.
a:link -> Targets anchor tags that have not yet been visited
a:visited -> Targets anchor tags that have been visited.
a:hover -> Targets an element when the cursor is placed over it.
a:active -> Targets an element when it is being clicked
state pseudo-classes guidance:
It is best practice to style the pseudo-classes of anchor tags instead of styling the anchor elements directly.
Conditional pseudo-classes:
Styling based on an elements position in relation to other elements e.g.
li:first-child -> Targets the first child element
li:last-child -> Targets the last child element
li:nth-child(n) -> Targets child elements based on their position (every nth child)
Combinator Selectors:
Combines two or more selectors to target elements based on their positions relative to each other. e.g. below:
div p -> DESCENDANT (CHILD) SELECTOR (used sometimes). Targets all children elements of a parent.
div > p -> DIRECT DESCENDANT (CHILD) SELECTOR (rarely used). Targets only direct children elements of a parent.
h1 + p -> ADJACENT SIBLING SELECTOR (rarely used). Targets an element directly after another element both nested within the same parent.
h1 ~ p -> GENERAL SIBLING SELECTOR (rarely used). Targets multiple elements directly after another element both nested within the same parent.
Conflicting Selectors:
When styles are applied to the same element using a different type of selector the outcome is determined by specificity. e.g.
<body>
    <h1 class="heading">Banjo Skateboard</h1>
</body>
.heading { color:blue; }    h1 { color: green; }
The h1 element and the .heading class point to the same selectors.
Specificity determines the priority of a CSS rule when multiple rules apply to the same element.
Specificity guidance:
It is common to use the type selector for global styles and the class selector to override this for specific styling.
CSS Inheritance:
This is when properties set on parent elements are passed to their children by default.
<div class="hero-section">
    <h1>Asymmetrical beard</h1>
    <p>Retro distillery banjo</p>
</div>
.hero-section { color: blue; } The blue color in the hero-section class type selector is inherited for both h1 and p elements. p { color: red; }
Specific selectors will override inherited styles as inherited styles have a very low specificity. In the example above the p element selector will override the class selector.
The p element selector has a higher specificity.
What gets inherited? It is mainly text properties that are inherited from parent to child. Properties such as: color, font-weight, line-height, font-family
inheritance guidelines:
Global font-styles are set on the body elements so that all child text elements inherit styles by default.
Next, set global font styles on type selectors which will override inherited properties.
Inheritance is also often utilised for a container that requires specific text styling.
Text-align affects block-level elements but has no impact on inline-level elements.
When applying the text-align property to a block-level parent containing inline elements, all children will be impacted.
The Universal Selector:
Applies styles to all elements. Symbolized by * e.g. * { color: blue; border-top: 5px solid red; }
the universal selector guidance:
Primarily used for resetting default properties and is not typically used for applying specific styling.
Universal Selector ve Body Tag Inheritance
Body Tag & Inheritance { Only applies text properties, Used to set default text properties across  application }
The universal selector { Applies all properties to all elements, Used to reset default styles }
Pseudo-elements:
Used to style a specific part of an element. e.g. h2::first-letter{ pseudo-selector name }
For text-styling -> used to enhance visual appearance of text. e.g. ::first-letter  ::first-line{paragraph opening line}
For selection -> Used to visually enhance the text a user selects. e.g. ::selection
For content insertion -> Used for adding decorative elements without altering HTML structure. e.g. ::before ::after

THE CSS BOX MODEL
Describes how all HTML elements are treated as rectangular boxes.
Each box has its own set of properties.
The CSS box model also applies to container elements like divs and semantic elements.
Padding -> Space between content and border & still part of the element. Content -> text, images, links, forms etc
Border -> A line around the element & still part of the element.
Margin -> Space outside the element, separating it from other elements.
Background-Color property:
Sets the background color of an element and applies to the content and any padding NOT the border.
background-color: #339af0; other values can be: rgb rgba hsl hex(most commonly used).
background-color guidance:
Sometimes used to set the background color of entire page.
Commonly used to set the background color of page sections.
Commonly used in components(piece of reusable ui).
Color vs Background Color:
Color -> Applies to text elements e.g. color: #339af0;
background-color -> Applies to the background of an element e.g. background-color: #339af0;
Width & Height:
Box model: Each rectangular box has height and width
Default block-level element dimensions:
By default block-level elements are just big enough to fit its contents vertically and stretches full width horizontally.
The height of block-level elements such as h1 and p is set by font-size.
Block-level elements span full width of the page.
Block elements container such as div, article and section span full width of page. Height is the sum of font-size and some margin.
Default inline-level element dimensions:
By default inline-level elements are just big enough to fit its contents both vertically and horizontally.
The height and width of inline elements such as anchor tag a and image tag img are determined by font-size of anchor tag and those of the img tag are determined by height and width of the img.
Width & Height properties:
The default box dimensions can be overwritten by the width & height properties. e.g. width: 500px; height: 100px;
Can override default dimensions or set dimensions where none exist.
Block-level sizing guidance:
For individual elements such as h1, p, ul & li -> usually do not set height but let it be automatically determined. Margins, paddings & font-size determine the height.
Width -> Usually do not set width which will stretch to fill the parent container
For container elements such as div and section, height -> usually do not set height but let it be automatically determined.
                                                width -> depending on the layout it can be common to set a width
It is common to set the width manually but not the height.
Inline-level sizing guidance:
Width and height can be set on some inline-elements but not others.
Some of the elements that you can apply width & height: img, input, select, textarea, button
For img setting height or width will adjust the other dimension automatically to preserve aspect ratio. This ratio is between width and height.
Some of the elements that you can't apply width and height: span, a, sub, sup
For the a element it is common to use padding to create space around anchor text
Padding:
Padding is the space between the content of an element and its border to improve readability and visual design.
Longhand padding:
Sets the padding on individual sides. e.g. padding-top: 5px; padding-right: 10px; padding-bottom: 5px; padding-left: 10px;
Shorthand padding:
Sets the padding on all sides at once.e.g. padding: 20px; -> on all sides  padding: 10px 20px; -> vertical & horizontal
padding: 10px 20px 5px; -> top, horizontal & bottom{uncommon}   padding: 10px 20px 5px 15px; -> top, right, bottom, left{each side - kinda common}
padding guidance:
Commonly used in buttons and text callouts to improve readability.
Also commonly used in cards.
Also commonly used on inputs.
For padding inside buttons use a rule of thumb: padding on the horizontal doubles padding on the vertical.
Border:
A border creates a visible boundary around an HTML element and can enhance visual appearance and separation from other elements.
Longhand border properties:
Sets the individual border properties & applies to all four borders.
width -> border thickness -> border-width: 5px; default value - 0px common value - px other values - em rem
style -> border line style -> border-style: solid; default value - none common value - solid other values - dotted dashed double
color -> border color -> border-color: red; default value - element color e.g. rgb hex
Shorthand border properties:
Sets all the border properties in one go & applies to all four borders. This is the more common practice. e.g. border: 5px solid red;
Individual border properties:
Sets all the border properties in one go & applies to one border at a time e.g. below:
border-top: 6px solid purple;    border-right: 2px dashed blue;    border-bottom: 1px dotted red;    border-left: 10px double green;
border guidance:
Borders help with grouping related content
Individual borders help separate sections
Borders can create outline buttons which are commonly used alongside solid filled buttons.
It is common to add a border on a filled button which matches its background color when used alongside an outline button.
The filled button should have a border-color which is the same as the background color
Border radius:
Rounds the corners of an element border.
Sets the border radius value. border-radius: 12px; other values: px{commonly used} em rem %
Pills:
Fully rounded corners are created from rectangles by setting border radius equal to half the elements height. So if the height: 100px; then border-radius: 50px;
Circles:
Circular elements are created from squares by setting border radius equal to half the elements height. So if the height: 100px; then border-radius: 50px;
Because this is a square, this means that it has the same height as width;
border radius guidance:
Square corners are more formal.
Rounding corners can be perceived as more friendly.
Fully rounding corners can be perceived as playful.
It is important to have consistent rounding across all elements.
Box Sizing:
Total box dimensions -> By default the total width and height of a box will be the sum of the content width and height, padding and border
The box-sizing property modifies how the total width and height of an element are calculated. e.g. box-sizing: border-box; other values: content-box{default value} border-value{commonly used}
Content-box -> The total dimensions is sum of content, padding and border. The set width & height will be smaller than the total width & height of the box. Content dimensions are unchanged.
Border-box -> The total dimensions include content, padding and border. The set width & height will match the total width & height of the box. Content dimensions need to reduce.
box-sizing guidance:
Set the border-box on the universal selector. * { box-sizing: border-box; } -> sets border-box on all boxes. One of the first things to do in a new css document.
Margin:
This is the space outside of an element's border creating distance between it and neighboring elements.
Longhand margin:
Sets the margin on individual sides e.g. margin-top: 5px; margin-right: 20px; margin-bottom: 5px; margin-left: 20px;
Shorthand margin:
Sets the margin on all sides at once. see examples below:
all sides -> margin: 20px; vertical & horizontal -> margin: 10px 20px; top, horizontal & bottom -> margin: 10px 20px 5px; each side -> margin: 10px 20px 5px 15px;
margin guidance:
Use margin to apply whitespace between groups of elements.
Use margin to apply whitespace between sections.
It is common to control spacing between elements with margin and other more modern techniques.
Spacing system:
A predefined spacing system simplifies the design process and ensures consistency. e.g. 5px 10px(base unit) 15px 20px 25px 30px 40px 50px 60px 70px 80px 90px 100px 125px 150px 200px 250px 300px 400px 500px
Margin is typically used to help us separate between major sections.
Display Property:
All HTML elements are by default either a block or inline element
Block elements -> Starts on a new line. Takes up full width of a page. Width & height can be set. Padding applies. Border applies. Margin applies. display: block; by default. e.g. <h1> <p> <ul> <li>
Inline elements -> Does not start on a new line unless after a block element. Only occupies width of their content. Width & height cannot be set. Padding only pushes content
horizontally. Border only pushes content content away horizontally. Margin only applies horizontally. display: inline; by default. e.g. <a> <img> <br> <input> <span>
Block elements and the box model:
Block elements follow the box model rules so applying any properties work as expected.
Inline elements and the box model:
Inline elements do not follow the box model rules so applying some properties do not work as expected. e.g for anchor tag the width & height cannot be set. The anchor tag assumes the
width & height of the content. This is the case for inline elements.
Padding applies but only pushes content away horizontally and not vertically.
Margin only applies horizontally and not vertically.
Display Property:
Sets how the element is formatted and positioned. e.g. display: block;
Other values: block{default values for block elements}, inline{default value for inline elements} inline-block, flex grid.
Inline-block:
Combines features of block and inline elements
display: inline-block; Does not start on a new line. Only occupies width of their content. Width & height can be set. Padding applies. Border applies. Margin applies.
inline-block guidance:
It is common to apply inline-block to inline elements so they flow inline(next to each other) but all box properties(padding, border & margin) can be applied e.g two buttons side-by-side.
Replaced inline elements:
Inline elements where the content is sourced externally and is not part of the HTML markup. The difference between regular and replaced inline elements is as follows:
Replaced inline elements same as regular inline elements do not start on a new line. Also, both occupy width of their content.
Whereas regular inline elements width & height cannot be set, replaced inline elements width & height can be set.
For replaced inline elements padding, borders & margin do not apply as expected. Whereas for replaced inline elements, padding, borders & margin apply as expected.
Regular inline elements: <a> <span> <sub> <sup>
Replaced inline elements: <img> <input> <select> <textarea>. Box properties do apply and hence no need for display: inline-block; property.
Browser default properties:
Browsers have built-in CSS default rules that style HTML elements. see below:
<body>    -> 8px margin
<h1>      -> 21px margin top & bottom,  32px font-size,  700 font-weight
<p>       -> 16px margin top & bottom,  16px font-size,  400 font-weight
<ol> <ul> -> 16px margin top & bottom, 40px left padding
CSS Reset:
It is very common to strip away the main default browser styles to give us a blank canvas to work from.
Global resets :  * { box-sizing: border-box; margin:0; padding:0; }
Element resets :   a { text-decoration: none; display: inline-block; }  ul, ol { list-style: none; }
Normalize CSS:
Creates uniform default styles for HTML elements without removing all styles like a reset does. This is a large CSS file added to your project. It is grabbed online.
You get it online by typing normalize css on google search and clicking NORMALIZE.CSS which is the first link and then downloading the file.
Main Container:
Container: It is very common for a webpage to have a wrapper which adds margin left & right as well as centers all the content.
To create a container, a suitable width is chosen to prevent content from excessively stretching on larger screen sizes.
Centering the container:
To center the container, calculate the remaining width and distribute the space to margin left and margin right equally.
Auto:
A value that enables the browser to automatically determines a property's size. e.g. height: auto;
For images, automatically applies to the other dimension when setting width or height to preserve aspect ratio. e.g. img { width: 400px; height: auto; } the height auto property is applied
behind the scenes.
For margins, automatically calculates the remaining space inside a parent and used to center a child container. e.g. .container { width: 1200px; margin-left: auto; margin-right: auto; } The
margin-left and margin-right auto centers the container.
Using the shorthand margin property is concise and more common. e.g. .container { width: 1200px; margin: 0 auto; } same as applying auto to margin left and margin right with margin top and
bottom set to (0)zero.
Max Width:
Ensures elements are responsive for different screen sizes. Width: 500px; sets a fixed width of 500px. max-width: 500px; sets an elements width that it won't exceed. In this case won't go
above 500px.
Block and Inline elements: max width behaves differently depending on the display property of the html element.
Block elements <h1> <div> -> occupies full width of parent. width and height can be set.
Regular inline elements <a> <span> -> only occupies width of their content. Width & height cannot be set. Need to change display to inline-block so we can apply min/max width.
Replaced inline elements <img> <input> -> only occupies width of their content. width & height can be set.
Max-width on block elements:
Sets the maximum width an element can be while it can still go narrower. Assuming the maximum width of the browser is 1800px and the width has been set to 1200px or the max-width has been set to 1200px.
Block elements stay at 1200px when browser is wider. When the width of the browser is reduced by use of chrome dev tools and the width had been set to 1200px. Block elements extend beyond the browser. If
the max-width had been set to 1200px and the width of the browser  is reduced then the block element reduces when the browser is narrower.
Max-width block element guidance:
Using max-width on a main container ensures content does not go too wide on larger screens.
Max-width on inline elements:
Sets the maximum width an element can be while it won't go narrower. Assuming the width of the browser is 1800px and the width of the inline element has been set to 1200px. Inline element width stays
at 1200px when the browser is wider. If the width of the browser is reduced in chrome dev tools in responsive manner, inline elements extend beyond the browser when it is narrower. Max-width has no
impact on an inline element.
Inline elements do not automatically expand to fill the width of their container. So setting the width 100% ensure they do take up the full width available. Allowing max-width if set to limit their size.
max-width inline element guidance:
Using max-width on images creates a responsive layout. You can't apply max-width without applying a width of 100%.
Min-Width:
Sets an elements width that it won't shrink below. e.g. min-width: 500px; ensures width won't go below 500px.
Both maximum and minimum width ensure elements are responsive for different screen sizes. Also both behave differently depending on the display property of HTML element.
Min-width on block elements:
Sets the minimum width an element can be while it can still go wider.
With the element width at 1200px and the browser's width at 1800px, when the browser narrows in chrome dev tools the block element extends beyond browser.
With the element min-width at 1200px and the browser's width at 1800px, the element stretches along the whole width of the browser. when the browser narrows in chrome dev tools the  block element
extends beyond browser.
min-width block element guidance:
Useful fo maintaining a section width in a grid layout so it does not become too narrow.
Min-width on inline elements:
Sets the minimum width an element can be while it can still go wider.
min-width inline element guidance:
Sometimes useful for spans as it ensures text does not become too narrow & improves visual consistency.
Max and Min Height:
height: 500px; -> sets a fixed height. max-height: 500px; -> sets an element's height that it won't exceed. Just like max-width, it can reduce in height.
min-height: 500px; -> sets an element's height that it won't shrink below. The height can expand beyond 500px.
Maximum and minimum properties:
Max and Min width are more commonly used compared to max & min height due to their role in creating responsive layouts.
max-height{least frequently used} -----> min-height -----> min-width -----> max-width {most frequently used}. All are more commonly applied to block elements especially for min and max height.
Max width vs max height:
max width and max height behave in fundamentally different ways. max-width -> based on its container, so it applies even without content. max-height -> only applies when content exceeds the limit.
Overflow:
Controls what happens to content that overflows an element's box e.g. overflow: hidden; other values visible(means overflow can happen. default value) scroll(introduces a scroll bar that will always be
present even if there is no overflow) auto(a scrollbar only when necessary) and hidden(clips the content, so that any content that overflows will be cut out).
It is more common to use overflow auto as opposed to overflow scroll because it is more versatile for other circumstances.
max-height guidance:
Used when you want to ensure elements do not exceed a certain height.
min-height guidance:
Used when you want to ensure elements maintain a minimum height regardless of the amount of content.


CSS UNITS:
Absolute and Relative units:
Relative units are essential for responsive webpages so elements can dynamically adjust for different screen sizes.
Absolute units -> size is fixed and does not change in relation to parent elements. e.g. px(used for specific cases) {pt in cm mm}uncommon.
Pixels are still being used in border-radius, border, letter-spacing, logo and icons, max-width and shadows.
Relative units -> size is based on the size of a parent element and adjusts proportionally to changes in the parent element. e.g. % em rem vh vw
Relative units are more commonly used in web pages.
Examples of where to use relative units: containers, box-model properties like margin and padding and font-size.
Percentages:
This is a unit that is always relative to some other value. There are two main use cases in css:
i) Relative to a parent and is commonly used in css properties like, width, height, margin and padding. This is very common.
ii) Relative to the element itself. This can be used on a property like a line-height. This is not very common. Example on the next line:
Assuming you define a font-size of 20px on some text and the line-height assign a percentage of 200% then the line-height will assume 40px.
percentage guidance:
Percentages are used in conjunction with max-width on main containers so that the webpage is fully responsive. The max-width is used to control the width of the content and container on
larger screens and percentage is used on the body so that when the webpage is accessed from a smaller screen prevents content going right up to the edges.
Percentages are used in conjunction with max-width on standalone images so that the webpage is fully responsive. Max-width is mainly applied for larger screens and percentages mainly applied
for smaller gadgets like phone. This is to make sure the webpage is responsive. Width set to 100% on smaller screens so image scales to full width of container. Main container values are set
to less than 100% and inline elements such as images majorly set to 100%.
It is common to set images inside a grid or flex container to 100% so it fills the cell and adapts responsively.
There are cases when you want to set a button width to 100% so it fills its container and adapts responsively.
Percentage values are used for fully rounded corners(border radius calculated automatically as half of container by giving it a value of 50%) as pixels require manual calculation. This is done on
elements like buttons and images.
Rems and Ems:
Rems -> These are a unit relative to the root elements font size and are the key ingredient for creating responsive webpages. The html tag is the root element which wraps all other elements. The font-size
of the root element is 16px. e.g. a { font-size: 2rem; } => 2 * 16px = 32px. The rem can also be used on non-font-size properties. e.g. margin, padding. We can change the default font-size of the root
element by html { font-size: 8px; } and so therefore any element set to 2rems will be 16px.
Working with a base 10px for rem units makes it simpler when thinking about sizing elements. html { font-size: 10px; } It is much better for scalability in web page responsiveness to set
the font-size to 62.5% which is an equivalent to 10px since the default chrome font-size for the root element is set at 16px. e.g. html { font-size: 62.5%; } The 16px font-size is equivalent to 1 rem.
rems guidance:
Rems are commonly used on font-size, margins and paddings to create fully responsive webpages.
Ems -> not frequently used as rems. This is a relative unit that is more context-specific(closer) compared to rems. Rems are relying on the root html element. Ems are not based on the root element.
They are based on the element much closer to the specific element that you are styling. They are mainly used for typography - relative to the font-size of the parent e.g. font-size, line-height and
letter-spacing. They are also used for other properties -> relative to the font-size of the element itself e.g. width, height, margin and padding.
ems guidance:
ems provide a higher level of precision for styling smaller components as sizing is based on font-size of the element itself.
VW & VH:
View-Height(VH) & View-Width(VW) are units that are a percentage of the browsers visible window. Assuming the dimensions of the browser are height: 1880px and width: 3000px. Then our element say a
container containing all the html markup we give it dimensions height: 80vh will be 1800px * 80% = 1440px and width: 50vw will be 3000px * 50% = 1500px.
vh and vw guidance:
VH can be used on section height e.g. hero sections in conjunction with min-height so content is always above the fold. Also set the value to min-height property in conjunction with VH.
VW can be useful for creating responsive text when it is a main standalone element and not confined within a container.


CSS FUNCTIONS:
These are a powerful tool for creating dynamic and maintainable styles in web design.
CSS Variables:
Allow us to store values to make it easier to maintain consistency and more easily make global style changes. They are also known as custom properties.
Defining a variable -> variables are set using double slashes, variable name and stored value. e.g. --primary: #339af0;
Using a variable -> background-color: var(--primary);
CSS variables are set on the root pseudo-class e.g. :root { --primary: #339af0; } then variables will be used in multiple locations.
Root pseudo-class:
A special pseudo-class selector that matches the root element in a document's hierarchy. The use of root pseudo-class :root { --primary: #339af0; } is basically the same as html { --primary: #339af0; }
But it is best practice to use root pseudo-class. There is a slight technical difference which makes the root pseudo-class more versatile.
CSS calculations:
We can perform dynamic calculations when setting values. e.g. calc function -> calc((100%/3) - 50px)
variables and calculations -> It is common to use variable and calculations in combination. e.g. :root { --text-h: 50px; } h1 { font-size: calc(var(--text-h1) + 10vw); } this ensures that the font-size
scales depending on the width of the browser.


FLEXBOX
The three major components of css:
content -> inside the box e.g. font-size, font-weight, background-color
box -> the box itself e.g. width & height, border, margin
layout -> where boxes go e.g. flexbox, grid, position
What is flexbox?
Flexbox is a one-dimensional layout model making it simple to arrange items in rows or columns and distribute space.
Flex container and flex items:
Flexbox has two main components. The first is the flex container which is the parent element. Inside the flex container, we have items, the flex items. which are the children of the flex container.
Display Flex:
The display property {display: flex;} on a container element will activate flexbox's layout features on children element.  It is declared on flex container(parent).
The values for display can include: block, inline, inline-block, flex, grid.
Flexbox takes full control of the LAYOUT, their alignment and spacing.
Main and Cross Axis:
The main axis is the primary direction in which flex items are laid out and cross axis determines distribution on secondary axis.
Flex Direction:
Controls orientation of the main axis. It is set on the flex container. e.g. flex-direction: row; {row is the default value. Items align from left to right} other values include row-reverse(items
align from right to left), column{changes the orientation of the main axis from top to bottom and the cross axis from left to right}, column-reverse{flips the direction of the main axis to go from bottom
to top with the cross axis still going from left to right}
flex-direction guidance:
In most cases flex-direction is set to row or column. You do not explicitly need to set flex-direction to row as it is the default value.
Normal Flow vs FlexBox
When flexbox is applied to a container it takes control of the alignment of children.
Normal flow -> Spacing and alignment are determined by inherit properties of block and inline elements. Block and inline elements behave differently in normal flow.
Note in normal flow the main idea is that positioning and size is mainly determined by whether an element is a block or inline element.
Flexbox -> Flexbox overrides default behavior of block and inline elements with spacing and alignment controlled by flexbox properties.
Normal flow and alignment:
Applying text-align to a block-level parent will impact both block and inline children through different mechanisms.
Applying text-align: center; directly to an inline element won't center it.
In flexbox container, applying box model properties such as height, margin and padding to inline elements works.
Applying text-align: center; to a flex container won't align all inline elements such as an image at the center of the flex container. In normal flow, everything is centered.
text-align: center; is no longer responsible for alignment inside a flex container.
Aligning and Spacing:
Flexbox offers a powerful way to space and align content
Flex container size -> understanding a flex container's dimensions is essential for visualising how flex items will be positioned. When thinking about the size of a flex container there are two
categories: 1. General Block container -> Block element extends full width of the container. Height of the flex container is being determined by the flex items. This means that there is no space
between the largest flex item and the container. 2. Container with a set width or height -> In this container there is a set width or height of the flex container. This mean that there may be
space between the largest flex item and the container. This space may be vertically or horizontally within the container.
Justify Content:
Sets how flex items are positioned along the main axis. It is set on the container and not the flex items. e.g. justify-content: flex-start;(default value) other values include flex-end, center,
space-between, space-around and space-evenly.
justify content guidance:
Often used to align and space navigation bars.
Can be used to align entire sections.
Often used for spacing and alignment of simple one-dimensional components.
Align items:
Sets how flex items are positioned along the cross axis. Set on the flex container e.g. align-items: stretch;{default value}. Other values include, align-items: flex-start; align-items: flex-end;
align-items: center; align-items: baseline;
Justify-content is about spacing and alignment along the main axis and align-items is about positioning and spacing along the cross-axis.
The Flex Container Axis:
                            ^
                            |
                            |
----------------------------|----------------------------> main axis (use justify-content to space and align items along the main axis)
                            |
                            |
cross-axis(use align-items to position and space items along the cross-axis)
When you set a specific height on a flex-item, the align-items: stretch; property no longer applies.
Align items and Shifting the main axis:
When no height is set on the container, its height is sum of flex item's height and justify content will have no impact.
When height is set on the container, there can be additional space so justify content will have an impact.
align-items guidance:
Commonly used on navigation menus and footers.
Often used to positioning items inside a component in a flex row.
Flexbox and the Box model:
Box model properties can still be used in a flexbox layout to control spacing. Margin can be used to space items and padding can be used in flex items.
Gap Property:
Sets uniform spacing between flex items on the main axis. Set on the flex container. e.g. gap: 24px; This can also be used when the main axis is shifted.
margin and gap guidance:
Margin us used when you want different spacing values between flex items.
Gap is used when you want uniform spacing values between flex items. This is the more commonly used property.
Nested Flexbox:
It is common to have a flexbox layout inside another flexbox layout.
A flex item within a flex container can also function as a flex container itself, allowing for multi-level flex layouts.
nested flexbox guidance:
Commonly used on navigation menus and footers.
Also commonly used in sections and components.
Centering:
Flexbox offers a modern & flexible approach to centering items vertically and horizontally.
horizontal centering a container: 1. Box model -> Margin can be applied left and right to horizontally center child containers. e.g. margin: 0 auto; applied on child container. 2. Flexbox -> Flex
properties make it simple to horizontally center flex items. Main axis in row - justify-content: center; main axis in column - align-items: center; This works even when flex container does not have set
width. This  is because the flex container is most likely a block element which by default will extend the full width of the page.
Horizontal centering content inside a container: 1. Box model -> Using padding to create internal space left and right gives the illusion that content inside a container is centered. e.g. padding:
0 200px; The padding property is applied on the child container. 2. Flexbox -> Box model properties still apply on flex items, so padding can still be used to create internal horizontal space. e.g.
padding: 0 200px; In the 2 ways, content inside container is centered.
Vertical centering  content in a container:
This works when the parent container has a set height. If the width is not set, then it assumes the full width of the page. 1. Box model -> There is no easy way to vertically center a child
container inside a parent container with a set height. 2. Flexbox -> Flexbox properties make it simple to vertically center flex items when the parent container has a set height. Using main axis
in row, and cross-axis in column, align-items: center; It is in the cross-axis that we vertically center. If the main axis is in column, justify-content: center;
It also works when the parent container has no set height. 1. Box model -> Padding can be applied to the top and bottom of the child container. e.g. padding: 200px 0; Padding property is applied
on the child container. 2. Flexbox -> If the parent container has no set height, we can't use the flexbox properties such as justify-content and align-items. Box model properties still apply on flex
items, so padding can be used to create internal vertical space. e.g. padding: 200px 0; The padding property is applied on the flex item.
centering guidance  :
horizontal centering guidance -> margin is often used to establish a web page's main container as it is a simple method for horizontal centering. It is sometimes used for regular content containers.
                                 flexbox properties make it simple to horizontally center regular content containers.
                                 padding is used to create equal internal space left and right around containers like cards and elements like anchor tags. Can also be used to create equal internal space
                                 left and right on flex containers.
vertical centering guidance -> flexbox properties are often used to vertically center UI elements inside a flex container that has a set height.
                               padding is used to create equal internal space top and bottom around containers like cards and elements like anchor tags. Can also be used to create equal internal space top
                               and bottom on flex containers.
                                       Box Model                                                            Flexbox
Horizontally centering                 margin 0 auto; used to center main page containers                   justify-content: center; align-items: center;
a container                            and sometimes regular content containers                             Used to horizontally center regular content containers.

Horizontally centering                                                                padding: 0 200px;
content inside a container             Used for creating equal horizontal space around content inside a container. Applies to both box model and flexbox property.

Vertically centering a                 No easy way.                                                         justify-content: center; align-items: center;
container                                                                                                   either of the above depending on the orientation of the main axis.
                                                                                                            Used to vertically center regular content containers.

Vertically centering                                                                  padding: 200px 0;
content inside a container             Used for creating equal vertical space around content inside a container. Applies to both box model and flexbox property.
Flex Children:
flex-item properties -> Flexbox also has properties that control the behavior and positioning of flex-items. Flex container{display: flex; flex-direction: column; justify-content: space-between;
align-items: center; gap: 2rem;} Flex-items{flex-basis: flex; flex-grow: 0; flex-shrink: 1; align-self: center; order: 2;}
Flex-grow:
Determines how flex-items expand to fill extra space in a container based on a set of proportions. e.g, flex-grow: 0;{0(zero) is the default value} The flex-grow property calculates how flex-items
can fill the extra space. Items grow based on their flex-grow value relative to the total.
Flex-shrink:
Determines how flex-items shrink relative to others in a container where there isn't enough space. e.g. flex-shrink: 1; {default value} if the flex-shrink value is set 0 on each of the flex-items
then the flex-items don't shrink and therefore overflow the flex container. If the flex-shrink value is set to another value other than 0 then the items shrink based on their flex-shrink value
relative  to the total.
Align-self:
Sets individual flex items alignment by overriding the flex containers default align-items value. e.g. align-self: flex-end; Other values include align-self: auto;{default value} align-self: stretch;
align-self: flex-start; align-self: flex-end; align-self: center; {align-items: flex-end; align-self: baseline;}
Order:
Changes the visual order of flex items independent of their order in the HTML markup. e.g. order: 0;{default value}. Assuming you have 4 flex-items and you set their order numbers as order: -1;
order: 0; order: 0; and order: 1; then they will be arranged in order from the lower value i.e. -1 to the higher value i.e. 1
Flex wrap and align content:
Pushes flex-items onto multiple lines instead of being forced to fit on a single line when they exceed the container. It works in both containers where the height of the container is set and where
the height of the container is not. It is set on the flex container. e.g. flex-wrap: wrap; other values include nowrap{default value}, wrap wrap-reverse.
Align-content:
Controls the alignment of flex-items along the cross-axis when there are multiple rows of flex-items. It is set on the flex container. e.g. align-content: flex-start; other values include:
stretch{default value}flex-start, flex-end, center, space-between and space-around. This property can only work when the flex-wrap: wrap; property has been set.
flex-wrap guidance: {not often required}
Wrapping is useful for simple linear layouts when elements need to wrap onto multiple lines.


CSS GRID
This is a two-dimensional layout model making it simple to arrange items in rows and columns.
CSS Grid has two main components: 1. Grid container(parent) 2. Grid Items(children)
Css Grid has two axis and the difference to flexbox is that we can't change the direction of the axis. 1. Column axis(vertical axis) 2. Row axis(horizontal axis)
The Grid is divided into grid cells by grid lines.
The grid item can be moved within the grid cell. It is possible to have a grid cell without a grid item.
Grid lines define grid tracks{rows and columns}.
Grid rows and columns can have spacing between them. The space between the rows is called the horizontal gap. The space between the columns is called the vertical gap.
Display Grid:
The display property on a container element will activate grid layout features on children elements. It is declared on the grid container(parent). e.g. display: grid;
css grid guidance:
Css Grid can be used for complex two-dimensional layouts.
Grid is also commonly used for major sections.
Grid is also commonly used for UI elements with consistent spacing in a one-dimensional row or column. This could also use flexbox.
CSS GRID vs FLEXBOX:
Flexbox:                                                                   Grid:
Smaller UI                                                                 Larger UI
display: flex;                                                             display: grid;
One-dimensional(row or column)                                             Two-dimensional(row and column)
Commonly used in navigation bars, footers, components(buttons,             Commonly used in complex-2D-layouts, feature sections and cards
callouts, inside cards), hero sections and forms
Grid columns and rows:
Grid items will appear in a single column by default. The height of the grid container is sum of grid items.
Grid template columns:
Sets the number of columns and width of each. e.g. grid-template-columns: 100px(column 1 and its width) 200px(column 2 and its width);
Grid template rows:
Sets the number of rows and height of each. e.g. grid template rows: 50px(row 1 and its height) 100px(row 2 and its height) 200px(row 3 and its height) 300px(row 4 and its height)
Fractional unit:
This is the fraction available space in the grid container. e.g. grid-template-columns: 1fr 3fr 4fr;
This is very commonly used in css grid.
Fractional unit and rows:
If height is set on a grid container, fr units proportionally distribute space to the grid items. e.g. grid-template-rows: 1fr 2fr 2fr;
If no height is set on a grid container, fr units use the height of the grid items to set height and space on the grid container. The grid container scales based on grid items.
Repeat function:
Used to repeat rows or column dimensions when they are recurring. e.g. grid-template-columns: repeat(4{number of rows or columns we wish to define}, 1fr{size value});
column and row guidance:
Columns are often set with fr units and the width of grid container is usually not set but extends width of the page.
The number of rows are not usually set but are automatically defined by the number of grid items. Grid container width extends full width of page.
The height of the grid container is not usually set but defined by the sum of the height of the grid items. Height of grid container is sum of height of the content in the grid items.
It is common to define grid layout for each row on section of the web page.
Grid Gap:
By default grid items are placed next to each other with no spacing between them.
Gap property:
The gap property creates space  between grid rows and columns. e.g. row-gap: 20px; column-gap: 40px;
Another version of the gap property that can be used is gap: 40px; this is the value for row gap and column gap set in one go.
gap guidance:
Commonly used to space grid items in major sections.
Commonly used for spacing in card layouts such as testimonials and features.
Grid Cell Alignment:
This is where grid items can be aligned inside grid cells if there is space available.
Justify items:
This is not justify-content which is used in flexbox,
Aligns grid items inside a grid cell along the row axis. e.g. justify-items: start; other values include, justify-items: end; justify-items: center; justify-items: stretch;{default value}
Align items:
Used same as in flexbox.
Aligns grid items inside a grid cell along the column axis. e.g. align-items: start; other values include,  align-items: end; align-items: center; align-items: stretch;{default value}
alignment guidance:
It is common to use grid alignment properties when one grid item is larger than another.
it is common to use grid and flexbox in parallel to achieve more precise control of layout. A grid item can be a flex container.
Grid Alignment:
Entire grid tracks can be aligned and distributed when there is extra space in the grid container.
Justify-content:
Same as in flexbox.
Aligns entire grid columns along the row axis. e.g. justify-content: space-evenly; Other values include, justify-content: start; justify-content: end; justify-content: center;
justify-content: space-between; justify-content: space-around;
Align Content:
Same property used as in flexbox.
Aligns entire grid rows along the column axis. e.g. align-content: center; other values include, align-content: start; align-content: end; align-content: center; align-content: space-between;
align-content: space-around; align-content: space-evenly;
Items vs Content:
Justify items          Align items                                      Justify content          Align content
Aligns grid items when grid cells have extra space.                     Aligns grid tracks when the grid itself has extra space.
Row Axis               Column Axis                                      Row Axis                 Column Axis
justify-items          align-items                                      justify-content          align-content
start      end      center      stretch                                 start   end   center   space-around   space-evenly   space-between
e.g. justify-items: center; align-items: end;                           e.g. justify-content: center;   align-content: end;
Grid items:
Placing Grid items:
Grid items are automatically placed in a grid based on the order they appear in the HTML.
Grid items can be moved to different cells. It is set on the grid item. e.g. grid-row: 1(start line) / 2(end line); other grid items move automatically when placing a grid item.
                                            Also set on the grid item.  e.g. grid-column: 2(start line) / 3(end line);
placing grid items guidance:
Placing grid items is used to achieve specific layouts.
Spanning Grid Cells:
Grid-row and Grid-Column can be used to have grid items span multiple rows or columns. e.g. grid item 1 spanning along the row-axis - grid-column: 1 / 4;
                                                                                       e.g. grid item 1 spanning along the column-axis - grid-row: 1(start line) / span 2(cells to span);
spanning grid cells guidance:
Grid cells can be spanned to create visually interesting designs.
Aligning Grid items:
Grid cell alignment can be overridden for individual items. This is not too common. Assuming a grid container with properties, justify-items: center; align-items: center; Grid item 2 can override the
fore-mentioned properties of the container by justify-self: end; align-self: start; other values include, start, end, center and stretch{default value}.


RESPONSIVE DESIGN:
Intro to responsive design:
There are a variety of devices with different screen sizes so webpages need to adapt for a more functional user experience. A webpage appears different between different devices such as a desktop, a laptop,
a tablet and a mobile phone.
Responsive design is powered by three main pillars: 1. Relative units like percentages and rems. 2. Fluid layouts, this is flexbox and grid. 3. Media Queries
Media Queries:
Applies styles to a webpage based on specific conditions. e.g. at-rule -> @media (max-width{condition}: 500px) { h2 {font-size: 14px;} (when page is less than 500px apply this rule)}
Some global styles like color & fonts are applied no matter what the screen size is. These are defined outside media queries.
The media queries are organized in descending order ensuring that the smaller screen is always last.
Relative Units:
Elements scale proportionally based on {parent container(percentages)} size or scalable {reference points(rems)}.
Rems inside media query conditions:
The rem value inside a media query condition(inside brackets) is always based on the {default browser font-size(16 px)}.
It is better practice to use rem value inside media query conditions as opposed to pixels.
Rems inside media queries:
Rem values scale proportionally, adjusting both existing and new values based on the updated root font size. see examples below:
Remember that the default browser font-size is 16px which is usually 1rem. Using the original root element html {font-size: 62.5%} -> 62.5% X 16px = 10px therefore 1rem = 10px. In the media query below:
@media (max-width: 62.5rem) { html { font-size: 50%; }} For a max-width of 1000px which is the same as 62.5rem the font-size is reduced by 80% to 8px -> 50% X 16px = 8px.
For Existing Properties Using Rems -> All properties using rems will automatically shrink to 80% of their original size.
Foe New Properties Inside Media Query -> New properties added with rem will be based on new pixel value, not 10px.
When adding new rem values inside a media query select values you would use for the base case and it will scale automatically. Don't worry about exact pixel values for each media query, focus on what you
would do on the base case.
Fluid Layouts:
Using flexbox and css grid allow layouts to dynamically adjust in size and position easily.
Breakpoints:
These are a specific screen width where a webpage's layout changes.
Selecting breakpoints:
Selecting breakpoints for specific devices is impractical as there are too many to cater for.
Knowing the ranges of common device screen sizes is helpful in thinking about breakpoints. There is no universal standard for these ranges.
Ultimately, selecting breakpoints should be design-led and determined by observing where the layout naturally 'breaks'.
When using max-width in media queries, there's no need to set a maximum range because styles will be applied automatically.
Ranges to keep in mind: <---576px---><---768px---><---1024px---><---1280px---><---1536px--->
                        XS          SM           MD            LG            XL           2XL   {XS-extra small SM-small MD-medium LG-large XL-extra large 2XL-twice extra large}
                       PHONE       PHONE       TABLETS         SMALL        LARGE        LARGE
                      PORTRAIT   LANDSCAPE                     LAPTOPS      LAPTOPS      SCREENS
CSS & Physical pixels:
A pixel is a single point of light on a digital display.
Physical Pixels:
A pixel does not have a fixed length and varies between screens.
CSS Pixels:
A CSS pixel has a length of 1/96 inch (0.0104 inch)
Pixels in Dev Tools vs Devices:
Pixel values in dev tools are not the same as device pixel values. dev tools -> css pixel, device -> physical pixel
CSS pixels are scaled depending on screen resolutions.
Scaling across different devices happens automatically.


POSITIONING:









